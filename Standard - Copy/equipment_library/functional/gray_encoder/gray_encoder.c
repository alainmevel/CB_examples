/*2023-10-03T11:12:51-01:00*/

/********************************************************************
 * gray_encoder.c
 * 
 * generated by: plcgen 3.1.391
 ********************************************************************/

#include "cb_comp.h"
#include "iec_1131.h"

#include "gray_encoder.h"

#include <math.h>

/**************************** Variables *****************************/

CB_Index gray_encoder__num = 0;
CB_Mem_Int *gray_encoder_binaryInput;
CB_Mem_Bool *gray_encoder_encoderFreezing;
CB_Mem_Bool *gray_encoder_bit00;
CB_Mem_Bool *gray_encoder_bit01;
CB_Mem_Bool *gray_encoder_bit02;
CB_Mem_Bool *gray_encoder_bit03;
CB_Mem_Bool *gray_encoder_bit04;
CB_Mem_Bool *gray_encoder_bit05;
CB_Mem_Bool *gray_encoder_bit06;
CB_Mem_Bool *gray_encoder_bit07;
CB_Mem_Bool *gray_encoder_bit08;
CB_Mem_Bool *gray_encoder_bit09;
CB_Mem_Bool *gray_encoder_bit10;
CB_Mem_Bool *gray_encoder_bit11;
CB_Mem_Bool *gray_encoder_bit12;
CB_Mem_Bool *gray_encoder_bit13;
CB_Mem_Bool *gray_encoder_bit14;
CB_Mem_Bool *gray_encoder_bit15;
CB_Mem_Int *gray_encoder_wordOutput;
CB_Mem_Bool *gray_encoder_validBit;
CB_Mem_Int *gray_encoder_testValue;
CB_Mem_Int *gray_encoder_index;
CB_Mem_Float *gray_encoder_rank;
CB_Mem_Int *gray_encoder_memoRank;
CB_Mem_Int *gray_encoder_inputValue;
CB_Mem_Bool *gray_encoder_d_presetting;
CB_Mem_Int *gray_encoder_v_d_presetting;

/**************************** Variables *****************************/

#define binaryInput (gray_encoder_binaryInput->CB_current_value)
#define encoderFreezing (gray_encoder_encoderFreezing->CB_current_value)
#define bit00 (gray_encoder_bit00->CB_current_value)
#define bit01 (gray_encoder_bit01->CB_current_value)
#define bit02 (gray_encoder_bit02->CB_current_value)
#define bit03 (gray_encoder_bit03->CB_current_value)
#define bit04 (gray_encoder_bit04->CB_current_value)
#define bit05 (gray_encoder_bit05->CB_current_value)
#define bit06 (gray_encoder_bit06->CB_current_value)
#define bit07 (gray_encoder_bit07->CB_current_value)
#define bit08 (gray_encoder_bit08->CB_current_value)
#define bit09 (gray_encoder_bit09->CB_current_value)
#define bit10 (gray_encoder_bit10->CB_current_value)
#define bit11 (gray_encoder_bit11->CB_current_value)
#define bit12 (gray_encoder_bit12->CB_current_value)
#define bit13 (gray_encoder_bit13->CB_current_value)
#define bit14 (gray_encoder_bit14->CB_current_value)
#define bit15 (gray_encoder_bit15->CB_current_value)
#define wordOutput (gray_encoder_wordOutput->CB_current_value)
#define validBit (gray_encoder_validBit->CB_current_value)
#define testValue (gray_encoder_testValue->CB_current_value)
#define index (gray_encoder_index->CB_current_value)
#define rank (gray_encoder_rank->CB_current_value)
#define memoRank (gray_encoder_memoRank->CB_current_value)
#define inputValue (gray_encoder_inputValue->CB_current_value)
#define d_presetting (gray_encoder_d_presetting->CB_current_value)
#define v_d_presetting (gray_encoder_v_d_presetting->CB_current_value)


/************************ Components offsets ************************/


/********************* Initialization function **********************/

int _equipment_library__gray_encoder_init(void)
{
	self.Bool+=2;
	self.Int+=5;
	self.Float+=1;


	return 0;
}


/************************ Behavior function *************************/

int equipment_library__gray_encoder(void)
{
	if (exec_term_node(self_num)) {

		/*********************** Internals variables ************************/

		gray_encoder_validBit = self.Bool+0;
		gray_encoder_testValue = self.Int+0;
		gray_encoder_index = self.Int+1;
		gray_encoder_rank = self.Float+0;
		gray_encoder_memoRank = self.Int+2;
		gray_encoder_inputValue = self.Int+3;
		gray_encoder_d_presetting = self.Bool+1;
		gray_encoder_v_d_presetting = self.Int+4;

		/********************* Pre-conditions execution *********************/

		/*no Pre-conditions*/

		/************************ Behavior execution ************************/

		{
			/* ----------------------------------------------------------------	*/
			/* Type : Model of Operative Behaviour					*/
			/* Category :  Sensors							*/
			/* Author : Dassault Systemes						*/
			/* Update date : June 2018							*/
			/* ----------------------------------------------------------------	*/
			/* This module simulates the behaviour 					*/
			/*   of a Gray encoder							*/ 
			/* ----------------------------------------------------------------	*/
			/* ----------------------------------------------------------------	*/
			/* Treatment of presetting fault						*/
			/* ----------------------------------------------------------------	*/
			if (d_presetting) inputValue = v_d_presetting;
			else inputValue = binaryInput;


			/* ----------------------------------------------------------------	*/
			/* Encoder management							*/
			/* ----------------------------------------------------------------	*/
			if (d_presetting) inputValue = v_d_presetting;
			else inputValue = binaryInput;

			if (!encoderFreezing) {
				if(inputValue < 65535) {
					wordOutput = 0;
					for (index = 0;index<=15;index++) {
						rank = pow(2.0,(2.0+index));
						memoRank = rank;
						testValue = inputValue % memoRank;
						validBit = 0;
						if (  (( rank /4) <= testValue  ) && ( testValue  < ( rank * 3 /4 ) )  ) validBit = 1;
						switch (index) {
							case 0:
								bit00 = validBit;
								if (validBit) wordOutput = wordOutput +pow(2.0,0.0);
								break;
							case 1:
								bit01 = validBit;
								if (validBit) wordOutput = wordOutput +pow(2.0,1.0);
								break;
							case 2:
								bit02 = validBit;
								if (validBit) wordOutput = wordOutput +pow(2.0,2.0);
								break;
							case 3:
								bit03 = validBit;
								if (validBit) wordOutput = wordOutput +pow(2.0,3.0);
								break;
							case 4:
								bit04 = validBit;
								if (validBit) wordOutput = wordOutput +pow(2.0,4.0);
								break;
							case 5:
								bit05 = validBit;
								if (validBit) wordOutput = wordOutput +pow(2.0,5.0);
								break;
							case 6:
								bit06 = validBit;
								if (validBit) wordOutput = wordOutput +pow(2.0,6.0);
								break;
							case 7:
								bit07 = validBit;
								if (validBit) wordOutput = wordOutput +pow(2.0,7.0);
								break;
							case 8:
								bit08 = validBit;
								if (validBit) wordOutput = wordOutput +pow(2.0,8.0);
								break;
							case 9:
								bit09 = validBit;
								if (validBit) wordOutput = wordOutput +pow(2.0,9.0);
								break;
							case 10:
								bit10 = validBit;
								if (validBit) wordOutput = wordOutput +pow(2.0,10.0);
								break;
							case 11:
								bit11 = validBit;
								if (validBit) wordOutput = wordOutput +pow(2.0,11.0);
								break;
							case 12:
								bit12 = validBit;
								if (validBit) wordOutput = wordOutput +pow(2.0,12.0);
								break;
							case 13:
								bit13 = validBit;
								if (validBit) wordOutput = wordOutput +pow(2.0,13.0);
								break;
							case 14:
								bit14 = validBit;
								if (validBit) wordOutput = wordOutput +pow(2.0,14.0);
								break;
							case 15:
								bit15 = validBit;
								if (validBit) wordOutput = wordOutput +pow(2.0,15.0);
								break;
						}
					}
				}
				else {
					bit00 = 0;
					bit01 = 0;
					bit02 = 0;
					bit03 = 0;
					bit04 = 0;
					bit05 = 0;
					bit06 = 0;
					bit07 = 0;
					bit08 = 0;
					bit09 = 0;
					bit10 = 0;
					bit11 = 0;
					bit12 = 0;
					bit13 = 0;
					bit14 = 0;
					bit15 = 0;
					wordOutput = 0;
				}
			}

		}

		CB_post_bool(gray_encoder_bit00);
		CB_post_bool(gray_encoder_bit01);
		CB_post_bool(gray_encoder_bit02);
		CB_post_bool(gray_encoder_bit03);
		CB_post_bool(gray_encoder_bit04);
		CB_post_bool(gray_encoder_bit05);
		CB_post_bool(gray_encoder_bit06);
		CB_post_bool(gray_encoder_bit07);
		CB_post_bool(gray_encoder_bit08);
		CB_post_bool(gray_encoder_bit09);
		CB_post_bool(gray_encoder_bit10);
		CB_post_bool(gray_encoder_bit11);
		CB_post_bool(gray_encoder_bit12);
		CB_post_bool(gray_encoder_bit13);
		CB_post_bool(gray_encoder_bit14);
		CB_post_bool(gray_encoder_bit15);
		CB_post_int(gray_encoder_wordOutput);

		/******************** Post-conditions execution *********************/

		/*no Post-conditions*/
	}

	/*************************** self update ****************************/

	self.Bool += 2;
	self.Int += 5;
	self.Float += 1;

	return 0;
}

