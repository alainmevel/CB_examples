/*2023-10-03T11:13:08-01:00*/

/********************************************************************
 * variable_speed_drive.c
 * 
 * generated by: plcgen 3.1.391
 ********************************************************************/

#include "cb_comp.h"
#include "iec_1131.h"

#include "variable_speed_drive.h"



/**************************** Variables *****************************/

CB_Index variable_speed_drive__num = 0;
CB_Mem_Bool *variable_speed_drive_voltage380;
CB_Mem_Bool *variable_speed_drive_cmdSupply;
CB_Mem_Bool *variable_speed_drive_sensorSupply;
CB_Mem_Bool *variable_speed_drive_forward;
CB_Mem_Float *variable_speed_drive_speedSetpoint;
CB_Mem_Bool *variable_speed_drive_forwardFB;
CB_Mem_Bool *variable_speed_drive_thermal;
CB_Mem_Float *variable_speed_drive_speedVal;
CB_Mem_Float *variable_speed_drive_speedPercent;
CB_Mem_Float *variable_speed_drive_increment;
CB_Mem_Bool *variable_speed_drive_memoFwd;
CB_Mem_Bool *variable_speed_drive_forwardState;
CB_Mem_Float *variable_speed_drive_wantedSpeed;
CB_Mem_Float *variable_speed_drive_nominalSpeed;
CB_Mem_Float *variable_speed_drive_nominalTime;
CB_Mem_Bool *variable_speed_drive_thermalLogic;
CB_Mem_Bool *variable_speed_drive_forwardFbLogic;
CB_Mem_Bool *variable_speed_drive_d_locking;
CB_Mem_Float *variable_speed_drive_v_d_locking;
CB_Mem_Bool *variable_speed_drive_d_electrical;
CB_Mem_Bool *variable_speed_drive_v_d_electrical;
CB_Mem_Bool *variable_speed_drive_d_forwardFB;
CB_Mem_Bool *variable_speed_drive_v_d_forwardFB;

/**************************** Variables *****************************/

#define voltage380 (variable_speed_drive_voltage380->CB_current_value)
#define cmdSupply (variable_speed_drive_cmdSupply->CB_current_value)
#define sensorSupply (variable_speed_drive_sensorSupply->CB_current_value)
#define forward (variable_speed_drive_forward->CB_current_value)
#define speedSetpoint (variable_speed_drive_speedSetpoint->CB_current_value)
#define forwardFB (variable_speed_drive_forwardFB->CB_current_value)
#define thermal (variable_speed_drive_thermal->CB_current_value)
#define speedVal (variable_speed_drive_speedVal->CB_current_value)
#define speedPercent (variable_speed_drive_speedPercent->CB_current_value)
#define increment (variable_speed_drive_increment->CB_current_value)
#define memoFwd (variable_speed_drive_memoFwd->CB_current_value)
#define forwardState (variable_speed_drive_forwardState->CB_current_value)
#define wantedSpeed (variable_speed_drive_wantedSpeed->CB_current_value)
#define nominalSpeed (variable_speed_drive_nominalSpeed->CB_current_value)
#define nominalTime (variable_speed_drive_nominalTime->CB_current_value)
#define thermalLogic (variable_speed_drive_thermalLogic->CB_current_value)
#define forwardFbLogic (variable_speed_drive_forwardFbLogic->CB_current_value)
#define d_locking (variable_speed_drive_d_locking->CB_current_value)
#define v_d_locking (variable_speed_drive_v_d_locking->CB_current_value)
#define d_electrical (variable_speed_drive_d_electrical->CB_current_value)
#define v_d_electrical (variable_speed_drive_v_d_electrical->CB_current_value)
#define d_forwardFB (variable_speed_drive_d_forwardFB->CB_current_value)
#define v_d_forwardFB (variable_speed_drive_v_d_forwardFB->CB_current_value)


/************************ Components offsets ************************/


/********************* Initialization function **********************/

int _equipment_library__variable_speed_drive_init(void)
{
	(variable_speed_drive_voltage380)->CB_current_value = 1; /*voltage380*/
	(variable_speed_drive_cmdSupply)->CB_current_value = 1; /*cmdSupply*/
	(variable_speed_drive_sensorSupply)->CB_current_value = 1; /*sensorSupply*/
	(self.Float+2)->CB_current_value = 5000.0; /*nominalSpeed*/
	(self.Float+3)->CB_current_value = 0.5; /*nominalTime*/
	(self.Bool+3)->CB_current_value = 1; /*forwardFbLogic*/
	(self.Float+4)->CB_current_value = 5000.0; /*v_d_locking*/
	self.Bool+=9;
	self.Float+=5;


	return 0;
}


/************************ Behavior function *************************/

int equipment_library__variable_speed_drive(void)
{
	if (exec_term_node(self_num)) {

		/*********************** Internals variables ************************/

		variable_speed_drive_increment = self.Float+0;
		variable_speed_drive_memoFwd = self.Bool+0;
		variable_speed_drive_forwardState = self.Bool+1;
		variable_speed_drive_wantedSpeed = self.Float+1;
		variable_speed_drive_nominalSpeed = self.Float+2;
		variable_speed_drive_nominalTime = self.Float+3;
		variable_speed_drive_thermalLogic = self.Bool+2;
		variable_speed_drive_forwardFbLogic = self.Bool+3;
		variable_speed_drive_d_locking = self.Bool+4;
		variable_speed_drive_v_d_locking = self.Float+4;
		variable_speed_drive_d_electrical = self.Bool+5;
		variable_speed_drive_v_d_electrical = self.Bool+6;
		variable_speed_drive_d_forwardFB = self.Bool+7;
		variable_speed_drive_v_d_forwardFB = self.Bool+8;

		/********************* Pre-conditions execution *********************/

		/*no Pre-conditions*/

		/************************ Behavior execution ************************/

		{
			/* ----------------------------------------------------------------	*/
			/* Type : Model of Operative Behaviour					*/
			/* Category :  Associations - motors					*/
			/* Author : Dassault Systemes						*/
			/* Update date : June 2018							*/
			/* ----------------------------------------------------------------	*/
			/* This module simulates the behaviour of a motor, its variable	*/
			/* speed drive and its electrical control logic.			*/
			/* The speed setpoint can go from -100% to +100%.			*/
			/* ----------------------------------------------------------------	*/


			/* ----------------------------------------------------------------	*/
			/* Management of orders from Control Part					*/
			/*	if there is no power supply for command 				*/
			/*     	the contactors don't understand the control order	*/
			/*	The contactors cannot be active in the same time		*/
			/*	 	(mechanical security).					*/
			/* ----------------------------------------------------------------	*/
			if (forward && cmdSupply) memoFwd = 1;
			if (!forward || !cmdSupply || d_electrical) memoFwd = 0;


			/* ----------------------------------------------------------------	*/
			/* Calculation of the on-state of contactor				*/
			/* ----------------------------------------------------------------	*/
			forwardState= memoFwd & voltage380;

			/* ----------------------------------------------------------------	*/
			/* Management of the speed ramp						*/
			/* ----------------------------------------------------------------	*/
			if (d_locking)  speedVal = v_d_locking;
			else {
				/* Compute the increment of rotation accoring to the simulation clock */
				if (nominalTime > 0.0)
					increment = (nominalSpeed / nominalTime) * (CLOCK_PERIOD/1000000.0);

				/* Compute the wanted speed according to the speed setpoint	*/
				if (forwardState && (speedSetpoint >= -100.0) &&  (speedSetpoint <= 100.0)) wantedSpeed = (speedSetpoint / 100.0) * nominalSpeed;
				if (! forwardState) wantedSpeed = 0.0;
				
				/* Compute the speed ramp	*/
				if ( speedVal < wantedSpeed ) {
					speedVal += increment;
					if (speedVal > wantedSpeed)  speedVal = wantedSpeed;
				}
				if ( speedVal > wantedSpeed ) {
					speedVal -= increment;
					if (speedVal < wantedSpeed)  speedVal = wantedSpeed;
				}
			}

			/* ----------------------------------------------------------------	*/
			/* Compute the percentage between the current and nominal speed	*/
			/* ----------------------------------------------------------------	*/
			if (nominalSpeed != 0.0) 
				speedPercent = ((speedVal/nominalSpeed)*100);


			/* ----------------------------------------------------------------	*/
			/* Management of the thermal feedback					*/
			/* ----------------------------------------------------------------	*/
			if (d_electrical) thermal=v_d_electrical;
			else
				if (sensorSupply) thermal= ! thermalLogic;
				else thermal=0;

			/* ----------------------------------------------------------------	*/
			/* Management of feedback to Control Part					*/
			/*     if a fault is required, the contactor feed-back 		*/
			/*		 takes a preset state.					*/
			/*	if there is no power supply for sensors 				*/
			/*         contactor feed-back returns nothing				*/
			/*     else contactor feed-back returns the contactor state combined	*/
			/*	    with wiring logic.						*/
			/* ----------------------------------------------------------------	*/
			if (d_forwardFB) forwardFB=v_d_forwardFB;
			else
				if (sensorSupply) forwardFB=(memoFwd ^ ! forwardFbLogic);
				else forwardFB=0;


		}

		CB_post_bool(variable_speed_drive_forwardFB);
		CB_post_bool(variable_speed_drive_thermal);
		CB_post_float(variable_speed_drive_speedVal);
		CB_post_float(variable_speed_drive_speedPercent);

		/******************** Post-conditions execution *********************/

		/*no Post-conditions*/
	}

	/*************************** self update ****************************/

	self.Bool += 9;
	self.Float += 5;

	return 0;
}

