/*2023-10-03T11:13:20-01:00*/

/********************************************************************
 * cam_1dir_2speed.c
 * 
 * generated by: plcgen 3.1.391
 ********************************************************************/

#include "cb_comp.h"
#include "iec_1131.h"

#include "cam_1dir_2speed.h"

#include <math.h>

/**************************** Variables *****************************/

CB_Index cam_1dir_2speed__num = 0;
CB_Mem_Bool *cam_1dir_2speed_highSpeed;
CB_Mem_Bool *cam_1dir_2speed_lowSpeed;
CB_Mem_Float *cam_1dir_2speed_positionTranslat;
CB_Mem_Float *cam_1dir_2speed_percentTranslat;
CB_Mem_Float *cam_1dir_2speed_incrementTranslat;
CB_Mem_Float *cam_1dir_2speed_angleRotationDeg;
CB_Mem_Float *cam_1dir_2speed_angleRotationRad;
CB_Mem_Bool *cam_1dir_2speed_firstCycle;
CB_Mem_Float *cam_1dir_2speed_incrementRotation;
CB_Mem_Bool *cam_1dir_2speed_memoHs;
CB_Mem_Bool *cam_1dir_2speed_memoLs;
CB_Mem_Float *cam_1dir_2speed_oldPosition;
CB_Mem_Float *cam_1dir_2speed_maxTranslat;
CB_Mem_Float *cam_1dir_2speed_highSpeedVal;
CB_Mem_Float *cam_1dir_2speed_initTranslat;
CB_Mem_Float *cam_1dir_2speed_minTranslat;
CB_Mem_Float *cam_1dir_2speed_lowSpeedVal;
CB_Mem_Bool *cam_1dir_2speed_d_locking;
CB_Mem_Bool *cam_1dir_2speed_v_d_locking;

/**************************** Variables *****************************/

#define highSpeed (cam_1dir_2speed_highSpeed->CB_current_value)
#define lowSpeed (cam_1dir_2speed_lowSpeed->CB_current_value)
#define positionTranslat (cam_1dir_2speed_positionTranslat->CB_current_value)
#define percentTranslat (cam_1dir_2speed_percentTranslat->CB_current_value)
#define incrementTranslat (cam_1dir_2speed_incrementTranslat->CB_current_value)
#define angleRotationDeg (cam_1dir_2speed_angleRotationDeg->CB_current_value)
#define angleRotationRad (cam_1dir_2speed_angleRotationRad->CB_current_value)
#define firstCycle (cam_1dir_2speed_firstCycle->CB_current_value)
#define incrementRotation (cam_1dir_2speed_incrementRotation->CB_current_value)
#define memoHs (cam_1dir_2speed_memoHs->CB_current_value)
#define memoLs (cam_1dir_2speed_memoLs->CB_current_value)
#define oldPosition (cam_1dir_2speed_oldPosition->CB_current_value)
#define maxTranslat (cam_1dir_2speed_maxTranslat->CB_current_value)
#define highSpeedVal (cam_1dir_2speed_highSpeedVal->CB_current_value)
#define initTranslat (cam_1dir_2speed_initTranslat->CB_current_value)
#define minTranslat (cam_1dir_2speed_minTranslat->CB_current_value)
#define lowSpeedVal (cam_1dir_2speed_lowSpeedVal->CB_current_value)
#define d_locking (cam_1dir_2speed_d_locking->CB_current_value)
#define v_d_locking (cam_1dir_2speed_v_d_locking->CB_current_value)


/************************ Components offsets ************************/


/********************* Initialization function **********************/

int _equipment_library__cam_1dir_2speed_init(void)
{
	(self.Float+2)->CB_current_value = 1000.0; /*maxTranslat*/
	(self.Float+3)->CB_current_value = 2.0; /*highSpeedVal*/
	(self.Float+6)->CB_current_value = 1.0; /*lowSpeedVal*/
	self.Bool+=5;
	self.Float+=7;


	return 0;
}


/************************ Behavior function *************************/

int equipment_library__cam_1dir_2speed(void)
{
	if (exec_term_node(self_num)) {

		/*********************** Internals variables ************************/

		cam_1dir_2speed_firstCycle = self.Bool+0;
		cam_1dir_2speed_incrementRotation = self.Float+0;
		cam_1dir_2speed_memoHs = self.Bool+1;
		cam_1dir_2speed_memoLs = self.Bool+2;
		cam_1dir_2speed_oldPosition = self.Float+1;
		cam_1dir_2speed_maxTranslat = self.Float+2;
		cam_1dir_2speed_highSpeedVal = self.Float+3;
		cam_1dir_2speed_initTranslat = self.Float+4;
		cam_1dir_2speed_minTranslat = self.Float+5;
		cam_1dir_2speed_lowSpeedVal = self.Float+6;
		cam_1dir_2speed_d_locking = self.Bool+3;
		cam_1dir_2speed_v_d_locking = self.Bool+4;

		/********************* Pre-conditions execution *********************/

		/*no Pre-conditions*/

		/************************ Behavior execution ************************/

		{
			/* ----------------------------------------------------------------	*/
			/* Type : Model of Operative Behaviour					*/
			/* Category :  Actuators							*/
			/* Author : Dassault Systemes						*/
			/* Update date : June 2018							*/
			/* ----------------------------------------------------------------	*/
			/* This module simulate the behaviour of a cam with 1 direction and	*/
			/* 2 speeds.									*/
			/* The position of the cam goes from minTranslat to maxTranslat with	*/
			/* 2 rotation speeds highSpeedVal et lowSpeedVal.			*/
			/*										*/
			/* nota : the starting position is forced by initTranslat.		*/
			/* ----------------------------------------------------------------	*/

			/* Declaration of variables which don't need to be visualized during simulation */
			float pi=3.1415926;



			/* ----------------------------------------------------------------	*/
			/* Initialization of the position of the cam for the first step of	*/
			/* simulation.								*/
			/* ----------------------------------------------------------------	*/
			if (! firstCycle) {
				if (initTranslat > maxTranslat) positionTranslat = maxTranslat;
				else
					if (initTranslat < minTranslat) positionTranslat = minTranslat;
					else positionTranslat = initTranslat;

				firstCycle = 1;
				if ((maxTranslat - minTranslat) != 0.0)
					angleRotationRad = acos(1 - ((positionTranslat - minTranslat)/(maxTranslat - minTranslat)*2.0));
			}

			/* ----------------------------------------------------------------	*/
			/* Manage priorities of inputs' switching					*/
			/* ----------------------------------------------------------------	*/
			if (highSpeed && !memoLs) memoHs = 1;
			if (!highSpeed) memoHs = 0;
			if (!memoHs && lowSpeed) memoLs= 1;
			if (!lowSpeed) memoLs = 0;


			/* ----------------------------------------------------------------	*/
			/* Rotation and translation (height of cam)				*/
			/* ----------------------------------------------------------------	*/
			if ((!d_locking) && (memoHs || memoLs)) {

				/* compute the increment of rotation according to the clock of simulation	*/
				if (memoHs) incrementRotation = highSpeedVal * (CLOCK_PERIOD/1000000);
				if (memoLs) incrementRotation = lowSpeedVal * (CLOCK_PERIOD/1000000);

				/* compute the angle of rotation (radian)	*/
				angleRotationRad = angleRotationRad + incrementRotation;
				if (angleRotationRad >= (2*pi)) {angleRotationRad -= 2*pi;}
				
				/* compute the position of translation	*/
				positionTranslat=(1 - cos(angleRotationRad))*(maxTranslat-minTranslat)/2.0 + minTranslat;
			}

			/* ----------------------------------------------------------------	*/
			/* Compute the pecentage of height between the current position	*/
			/* and the lowest and highest points of the cam				*/
			/* ----------------------------------------------------------------	*/
			percentTranslat = (100/(maxTranslat - minTranslat)) * (positionTranslat - minTranslat)  ;
					

			/* ----------------------------------------------------------------	*/
			/* Conversion of the rotation angle from radian to degree		*/
			/* ----------------------------------------------------------------	*/
			angleRotationDeg = (angleRotationRad*180)/pi;

			/* ----------------------------------------------------------------	*/
			/* Increment of translation							*/
			/* ----------------------------------------------------------------	*/
			incrementTranslat = positionTranslat - oldPosition;
			oldPosition = positionTranslat;

		}

		CB_post_float(cam_1dir_2speed_positionTranslat);
		CB_post_float(cam_1dir_2speed_percentTranslat);
		CB_post_float(cam_1dir_2speed_incrementTranslat);
		CB_post_float(cam_1dir_2speed_angleRotationDeg);
		CB_post_float(cam_1dir_2speed_angleRotationRad);

		/******************** Post-conditions execution *********************/

		/*no Post-conditions*/
	}

	/*************************** self update ****************************/

	self.Bool += 5;
	self.Float += 7;

	return 0;
}

