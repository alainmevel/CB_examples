/*2023-10-03T11:13:21-01:00*/

/********************************************************************
 * axle.c
 * 
 * generated by: plcgen 3.1.391
 ********************************************************************/

#include "cb_comp.h"
#include "iec_1131.h"

#include "axle.h"



/**************************** Variables *****************************/

CB_Index axle__num = 0;
CB_Mem_Float *axle_speed;
CB_Mem_Float *axle_positionTranslat;
CB_Mem_Float *axle_percentTranslat;
CB_Mem_Float *axle_incTranslat;
CB_Mem_Bool *axle_firstCycle;
CB_Mem_Float *axle_nbCyclePerSec;
CB_Mem_Float *axle_initTranslat;
CB_Mem_Float *axle_maxTranslat;
CB_Mem_Float *axle_minTranslat;
CB_Mem_Bool *axle_d_locking;
CB_Mem_Bool *axle_v_d_locking;

/**************************** Variables *****************************/

#define speed (axle_speed->CB_current_value)
#define positionTranslat (axle_positionTranslat->CB_current_value)
#define percentTranslat (axle_percentTranslat->CB_current_value)
#define incTranslat (axle_incTranslat->CB_current_value)
#define firstCycle (axle_firstCycle->CB_current_value)
#define nbCyclePerSec (axle_nbCyclePerSec->CB_current_value)
#define initTranslat (axle_initTranslat->CB_current_value)
#define maxTranslat (axle_maxTranslat->CB_current_value)
#define minTranslat (axle_minTranslat->CB_current_value)
#define d_locking (axle_d_locking->CB_current_value)
#define v_d_locking (axle_v_d_locking->CB_current_value)


/************************ Components offsets ************************/


/********************* Initialization function **********************/

int _equipment_library__axle_init(void)
{
	(self.Float+2)->CB_current_value = 10000.0; /*maxTranslat*/
	self.Bool+=3;
	self.Float+=4;


	return 0;
}


/************************ Behavior function *************************/

int equipment_library__axle(void)
{
	if (exec_term_node(self_num)) {

		/*********************** Internals variables ************************/

		axle_firstCycle = self.Bool+0;
		axle_nbCyclePerSec = self.Float+0;
		axle_initTranslat = self.Float+1;
		axle_maxTranslat = self.Float+2;
		axle_minTranslat = self.Float+3;
		axle_d_locking = self.Bool+1;
		axle_v_d_locking = self.Bool+2;

		/********************* Pre-conditions execution *********************/

		/*no Pre-conditions*/

		/************************ Behavior execution ************************/

		{
			/* ----------------------------------------------------------------	*/
			/* Type : Model of Operative Behaviour					*/
			/* Category :  Actuators							*/
			/* Author : Dassault Systemes						*/
			/* Update date : June 2018							*/
			/* ----------------------------------------------------------------	*/
			/* This module simulates the behaviour of a limited axle to which a	*/
			/* to which a translation speed is imparted.				*/
			/* ----------------------------------------------------------------	*/

			/* ----------------------------------------------------------------	*/
			/* Initialise the position of the axle for the first step of 		*/
			/* simulation.								*/
			/* ----------------------------------------------------------------	*/
			if ( ! firstCycle) {
				if (initTranslat > maxTranslat) positionTranslat = maxTranslat;
				else if (initTranslat < minTranslat) positionTranslat = minTranslat;
					else positionTranslat = initTranslat;
				firstCycle = 1;
			}

			/* -----------------------------------------------------------------	*/
			/* Translation of the axle							*/
			/* -----------------------------------------------------------------	*/

			/* compute the increment of translation according to the simulation clock	*/
			incTranslat = 0.0;
			if (! d_locking) {
				nbCyclePerSec = CLOCK_PERIOD/1000000;
				incTranslat = speed * nbCyclePerSec;
			}
			positionTranslat = positionTranslat + incTranslat;

			/* -----------------------------------------------------------------	*/
			/* Limitation of the translation of the axle 				*/
			/* -----------------------------------------------------------------	*/
			if (positionTranslat > maxTranslat) {
				incTranslat -= positionTranslat - maxTranslat;
				positionTranslat = maxTranslat;
			}
			if (positionTranslat < minTranslat) {
				incTranslat -= positionTranslat - minTranslat;
				positionTranslat = minTranslat;
			}

			/* ----------------------------------------------------------------- */
			/* Compute the percent between the position and the limit		*/
			/* ----------------------------------------------------------------- */

			percentTranslat = (100/(maxTranslat - minTranslat)) * (positionTranslat - minTranslat)  ;
					



		}

		CB_post_float(axle_positionTranslat);
		CB_post_float(axle_percentTranslat);
		CB_post_float(axle_incTranslat);

		/******************** Post-conditions execution *********************/

		/*no Post-conditions*/
	}

	/*************************** self update ****************************/

	self.Bool += 3;
	self.Float += 4;

	return 0;
}

