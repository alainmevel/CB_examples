/*2023-10-03T11:12:58-01:00*/

/********************************************************************
 * conveyor_belt.c
 * 
 * generated by: plcgen 3.1.391
 ********************************************************************/

#include "cb_comp.h"
#include "iec_1131.h"

#include "conveyor_belt.h"

#include<math.h> 	/* pour fonction fabs */

/**************************** Variables *****************************/

CB_Index conveyor_belt__num = 0;
CB_Mem_Float *conveyor_belt_volumeIn;
CB_Mem_Float *conveyor_belt_depositPosition;
CB_Mem_Float *conveyor_belt_speed;
CB_Mem_Bool *conveyor_belt_openValve;
CB_Mem_Float *conveyor_belt_volumeOutFwd;
CB_Mem_Float *conveyor_belt_volumeOutBwd;
CB_Mem_Bool *conveyor_belt_controllerRot;
CB_Mem_Float *conveyor_belt_volumeOutValve;
CB_Mem_Float *conveyor_belt_materialHead;
CB_Mem_Float *conveyor_belt_materialTailEnd;
CB_Mem_Float *conveyor_belt_deviation;
CB_Mem_Float *conveyor_belt_volumeOn;
CB_Mem_Float *conveyor_belt_increment;
CB_Mem_Float *conveyor_belt_effectiveLength;
CB_Mem_Bool *conveyor_belt_valvePassage;
CB_Mem_Bool *conveyor_belt_controllerLogic;
CB_Mem_Float *conveyor_belt_conveyorLength;
CB_Mem_Float *conveyor_belt_controllerRotThres;
CB_Mem_Float *conveyor_belt_ratedSpeed;
CB_Mem_Float *conveyor_belt_weighingPosition;
CB_Mem_Float *conveyor_belt_valvePosition;
CB_Mem_Bool *conveyor_belt_d_sticking;
CB_Mem_Bool *conveyor_belt_v_d_sticking;

/**************************** Variables *****************************/

#define volumeIn (conveyor_belt_volumeIn->CB_current_value)
#define depositPosition (conveyor_belt_depositPosition->CB_current_value)
#define speed (conveyor_belt_speed->CB_current_value)
#define openValve (conveyor_belt_openValve->CB_current_value)
#define volumeOutFwd (conveyor_belt_volumeOutFwd->CB_current_value)
#define volumeOutBwd (conveyor_belt_volumeOutBwd->CB_current_value)
#define controllerRot (conveyor_belt_controllerRot->CB_current_value)
#define volumeOutValve (conveyor_belt_volumeOutValve->CB_current_value)
#define materialHead (conveyor_belt_materialHead->CB_current_value)
#define materialTailEnd (conveyor_belt_materialTailEnd->CB_current_value)
#define deviation (conveyor_belt_deviation->CB_current_value)
#define volumeOn (conveyor_belt_volumeOn->CB_current_value)
#define increment (conveyor_belt_increment->CB_current_value)
#define effectiveLength (conveyor_belt_effectiveLength->CB_current_value)
#define valvePassage (conveyor_belt_valvePassage->CB_current_value)
#define controllerLogic (conveyor_belt_controllerLogic->CB_current_value)
#define conveyorLength (conveyor_belt_conveyorLength->CB_current_value)
#define controllerRotThres (conveyor_belt_controllerRotThres->CB_current_value)
#define ratedSpeed (conveyor_belt_ratedSpeed->CB_current_value)
#define weighingPosition (conveyor_belt_weighingPosition->CB_current_value)
#define valvePosition (conveyor_belt_valvePosition->CB_current_value)
#define d_sticking (conveyor_belt_d_sticking->CB_current_value)
#define v_d_sticking (conveyor_belt_v_d_sticking->CB_current_value)


/************************ Components offsets ************************/


/********************* Initialization function **********************/

int _equipment_library__conveyor_belt_init(void)
{
	(self.Bool+1)->CB_current_value = 1; /*controllerLogic*/
	(self.Float+6)->CB_current_value = 20.0; /*conveyorLength*/
	(self.Float+7)->CB_current_value = 50.0; /*controllerRotThres*/
	(self.Float+8)->CB_current_value = 1.0; /*ratedSpeed*/
	(self.Float+9)->CB_current_value = 5.0; /*weighingPosition*/
	(self.Float+10)->CB_current_value = 10.0; /*valvePosition*/
	self.Bool+=4;
	self.Float+=11;


	return 0;
}


/************************ Behavior function *************************/

int equipment_library__conveyor_belt(void)
{
	if (exec_term_node(self_num)) {

		/*********************** Internals variables ************************/

		conveyor_belt_materialHead = self.Float+0;
		conveyor_belt_materialTailEnd = self.Float+1;
		conveyor_belt_deviation = self.Float+2;
		conveyor_belt_volumeOn = self.Float+3;
		conveyor_belt_increment = self.Float+4;
		conveyor_belt_effectiveLength = self.Float+5;
		conveyor_belt_valvePassage = self.Bool+0;
		conveyor_belt_controllerLogic = self.Bool+1;
		conveyor_belt_conveyorLength = self.Float+6;
		conveyor_belt_controllerRotThres = self.Float+7;
		conveyor_belt_ratedSpeed = self.Float+8;
		conveyor_belt_weighingPosition = self.Float+9;
		conveyor_belt_valvePosition = self.Float+10;
		conveyor_belt_d_sticking = self.Bool+2;
		conveyor_belt_v_d_sticking = self.Bool+3;

		/********************* Pre-conditions execution *********************/

		/*no Pre-conditions*/

		/************************ Behavior execution ************************/

		{
			/* -----------------------------------------------------------------	*/
			/* Type : Model of Operative Behaviour					*/
			/* Catégorie :   batch							*/
			/* Author : Dassault Systemes						*/
			/* Update date : June 2018							*/
			/* -----------------------------------------------------------------	*/
			/* This module simulates the bahaviour of a conveyor-belt driven by	*/
			/* an analog value of the speed.             				*/
			/* ----------------------------------------------------------------	*/


			/* Real variables of type 'double' are used for best accuracy		*/
			double head=0.0;	/* Position of material's head   		     	*/
			double tailEnd=0.0;	/* Position of material's tail end 		*/
			double incr=0.0;	/* Increment of position for head and/or tail end	*/
			double diff=0.0;	/* Length of material ejected by the conveyor-belt	*/

			head = materialHead;
			tailEnd = materialTailEnd;

			/* Manage the rotation controller						*/
			/* ----------------------------------------------------------------	*/
			if (d_sticking) controllerRot = v_d_sticking;
			else
				controllerRot = (fabs(speed) >= controllerRotThres) ^ !controllerLogic;



			/* Compute the position of material's ejection				*/
			/* ----------------------------------------------------------------	*/
			valvePassage=0;

			if(openValve) {
				if (speed>0.0)
				{
					effectiveLength=fabs(depositPosition - conveyorLength);
					if (valvePosition>=depositPosition)	
					{
						effectiveLength=fabs(depositPosition - valvePosition);
						valvePassage=1;
					}
				}
				else
				{
					effectiveLength=depositPosition;
					if (valvePosition<=depositPosition)	
					{
						effectiveLength=fabs(depositPosition - valvePosition);
						valvePassage=1;
					}
				}
			}
			else {
				if (speed>= 0.0) effectiveLength=fabs(depositPosition - conveyorLength);
				else effectiveLength= depositPosition;
			}

			/* Compute the position of material			 		*/
			/* ----------------------------------------------------------------	*/

			incr = speed * (CLOCK_PERIOD / 1000000);
			increment =incr;

			if  (volumeOn==0.0) {
			       head=tailEnd=depositPosition;
				materialHead = depositPosition;
			       materialTailEnd =depositPosition;
			}
			if((volumeIn==0.0)&& (materialHead!=depositPosition)) {
				head+=incr;
				materialHead=head;
				tailEnd+=incr;
				materialTailEnd = tailEnd;
			} 
			 else {
			 	tailEnd=depositPosition;
				materialTailEnd = depositPosition;
				if ((volumeOn != 0.0) || (volumeIn != 0.0)) head+=incr;
				materialHead=head;         
			}



			/* Compute the volume of material on the conveyor-belt bande        	*/
			/* ----------------------------------------------------------------	*/
			if ((materialHead-materialTailEnd !=0) || (speed==0.0))
			{
			          volumeOn += volumeIn;
			}
			if (volumeOn < 0.0) volumeOn = 0.0;



			/* Compute the volume of material ejected to BWD   			*/
			/* ----------------------------------------------------------------	*/
			volumeOutBwd = 0.0;
			volumeOutValve=0.0;
			if ((speed<0.0) && (head<0.0) && !valvePassage) {
				diff = fabs(head);
			              
				if (fabs(tailEnd - head) > 0.0) {
					volumeOutBwd= diff * volumeOn/ fabs(tailEnd - head);	
				}
				else volumeOutBwd=volumeOn;

				head=head+diff;
				materialHead = head;

			}
			if ((speed<0.0) && (head <= valvePosition) && valvePassage) {
				diff = -incr;
				if (fabs(tailEnd - head) > 0.0) {
					volumeOutValve= diff * volumeOn/ fabs(tailEnd - head);	
				}
				else volumeOutValve=volumeOn;

				head=head+diff;
				materialHead = head;
			}


			/* Compute the volume of material ejected to FWD   			*/
			/* ----------------------------------------------------------------	*/
			volumeOutFwd = 0.0;
			if ((speed>0.0) && (fabs(head) > fabs(depositPosition+effectiveLength))) {
				diff = fabs(fabs(head) - fabs(depositPosition+effectiveLength));
				deviation = diff;
				if (diff > 0.0) {
					if(valvePassage) {
						if(fabs(head - tailEnd)>0.0) volumeOutValve = diff * volumeOn /fabs(head - tailEnd);
						else volumeOutValve=volumeOn;
						volumeOutFwd=0.0;
					}
					else {
						if(fabs(head - tailEnd)>0.0) volumeOutFwd = diff * volumeOn /fabs(head - tailEnd);
						else volumeOutFwd=volumeOn;
						volumeOutValve=0.0;
					}
				}
				
				head=head-diff;
				materialHead = head;
			}



			/* Compute the volume of material on the conveyor   			*/
			/* ----------------------------------------------------------------	*/
			volumeOn +=  - (volumeOutBwd+volumeOutFwd+volumeOutValve);



		}

		CB_post_float(conveyor_belt_volumeOutFwd);
		CB_post_float(conveyor_belt_volumeOutBwd);
		CB_post_bool(conveyor_belt_controllerRot);
		CB_post_float(conveyor_belt_volumeOutValve);

		/******************** Post-conditions execution *********************/

		/*no Post-conditions*/
	}

	/*************************** self update ****************************/

	self.Bool += 4;
	self.Float += 11;

	return 0;
}

