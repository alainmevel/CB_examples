/*2023-10-03T11:13:20-01:00*/

/********************************************************************
 * cam.c
 * 
 * generated by: plcgen 3.1.391
 ********************************************************************/

#include "cb_comp.h"
#include "iec_1131.h"

#include "cam.h"

#include <math.h>

/**************************** Variables *****************************/

CB_Index cam__num = 0;
CB_Mem_Float *cam_rotationSpeedRadS;
CB_Mem_Float *cam_rotationSpeedDegS;
CB_Mem_Float *cam_positionTranslat;
CB_Mem_Float *cam_percentTranslat;
CB_Mem_Float *cam_incrementTranslat;
CB_Mem_Float *cam_angleRotationDeg;
CB_Mem_Float *cam_angleRotationRad;
CB_Mem_Bool *cam_firstCycle;
CB_Mem_Float *cam_incrementRotation;
CB_Mem_Float *cam_oldPosition;
CB_Mem_Float *cam_maxTranslat;
CB_Mem_Float *cam_initTranslat;
CB_Mem_Float *cam_minTranslat;
CB_Mem_Bool *cam_d_locking;
CB_Mem_Bool *cam_v_d_locking;

/**************************** Variables *****************************/

#define rotationSpeedRadS (cam_rotationSpeedRadS->CB_current_value)
#define rotationSpeedDegS (cam_rotationSpeedDegS->CB_current_value)
#define positionTranslat (cam_positionTranslat->CB_current_value)
#define percentTranslat (cam_percentTranslat->CB_current_value)
#define incrementTranslat (cam_incrementTranslat->CB_current_value)
#define angleRotationDeg (cam_angleRotationDeg->CB_current_value)
#define angleRotationRad (cam_angleRotationRad->CB_current_value)
#define firstCycle (cam_firstCycle->CB_current_value)
#define incrementRotation (cam_incrementRotation->CB_current_value)
#define oldPosition (cam_oldPosition->CB_current_value)
#define maxTranslat (cam_maxTranslat->CB_current_value)
#define initTranslat (cam_initTranslat->CB_current_value)
#define minTranslat (cam_minTranslat->CB_current_value)
#define d_locking (cam_d_locking->CB_current_value)
#define v_d_locking (cam_v_d_locking->CB_current_value)


/************************ Components offsets ************************/


/********************* Initialization function **********************/

int _equipment_library__cam_init(void)
{
	(self.Float+2)->CB_current_value = 1000.0; /*maxTranslat*/
	self.Bool+=3;
	self.Float+=5;


	return 0;
}


/************************ Behavior function *************************/

int equipment_library__cam(void)
{
	if (exec_term_node(self_num)) {

		/*********************** Internals variables ************************/

		cam_firstCycle = self.Bool+0;
		cam_incrementRotation = self.Float+0;
		cam_oldPosition = self.Float+1;
		cam_maxTranslat = self.Float+2;
		cam_initTranslat = self.Float+3;
		cam_minTranslat = self.Float+4;
		cam_d_locking = self.Bool+1;
		cam_v_d_locking = self.Bool+2;

		/********************* Pre-conditions execution *********************/

		/*no Pre-conditions*/

		/************************ Behavior execution ************************/

		{
			/* ----------------------------------------------------------------	*/
			/* Type : Model of Operative Behaviour					*/
			/* Category :  Actuators							*/
			/* Author : Techniques Nouvelles d'Informatique				*/
			/* Update date : October 2002						*/
			/* ----------------------------------------------------------------	*/
			/* This module simulate the behaviour of a cam (ovoid).		*/
			/* The position of the cam goes from minTranslat to maxTranslat with	*/
			/* the given rotation speed.						*/
			/*										*/
			/* nota : - the starting position is forced by initTranslat.		*/
			/*	   - the speed setpoint can be set in				*/
			/*		- radian per second	(rotationSpeedRadS)			*/
			/*		- degree per second	(rotationSpeedDegS)			*/
			/* ----------------------------------------------------------------	*/

			/* Declaration of variables which don't need to be visualized during simulation */
			float pi=3.1415926;


			/* ----------------------------------------------------------------	*/
			/* Initialization of the position of the cam for the first step of	*/
			/* simulation.								*/
			/* ----------------------------------------------------------------	*/
			if (! firstCycle) {
				if (initTranslat > maxTranslat) positionTranslat = maxTranslat;
				else
					if (initTranslat < minTranslat) positionTranslat = minTranslat;
					else positionTranslat = initTranslat;

				firstCycle = 1;
				if ((maxTranslat - minTranslat) != 0.0)
					angleRotationRad = acos(1 - ((positionTranslat - minTranslat)/(maxTranslat - minTranslat)*2.0));
			}

			/* ----------------------------------------------------------------	*/
			/* Rotation and translation (height of cam)				*/
			/* ----------------------------------------------------------------	*/
			if ((!d_locking) && ((rotationSpeedRadS!=0.0)||(rotationSpeedDegS!=0.0))) {

				/* compute the increment of rotation according to the clock of simulation	*/
				if (rotationSpeedRadS != 0.0) 
			 		 incrementRotation= rotationSpeedRadS* (CLOCK_PERIOD/1000000.0) ;
				else
				if (rotationSpeedDegS != 0.0)
					incrementRotation= rotationSpeedDegS* 2*pi*(CLOCK_PERIOD/360000000.0) ;

				/* compute the angle of rotation (radian)	*/
				angleRotationRad = angleRotationRad + incrementRotation;
				if (angleRotationRad >= (2*pi)) {angleRotationRad -= 2*pi;}
				
				/* compute the position of translation	*/
				positionTranslat=(1 - cos(angleRotationRad))*(maxTranslat-minTranslat)/2.0 + minTranslat;
			}

			/* ----------------------------------------------------------------	*/
			/* Compute the pecentage of height between the current position	*/
			/* and the lowest and highest points of the cam				*/
			/* ----------------------------------------------------------------	*/
			percentTranslat = (100/(maxTranslat - minTranslat)) * (positionTranslat - minTranslat)  ;
					
			/* ----------------------------------------------------------------	*/
			/* Conversion of the rotation angle from radian to degree		*/
			/* ----------------------------------------------------------------	*/
			angleRotationDeg = (angleRotationRad*180)/pi;

			/* ----------------------------------------------------------------	*/
			/* Increment of translation							*/
			/* ----------------------------------------------------------------	*/
			incrementTranslat = positionTranslat - oldPosition;
			oldPosition = positionTranslat;


		}

		CB_post_float(cam_positionTranslat);
		CB_post_float(cam_percentTranslat);
		CB_post_float(cam_incrementTranslat);
		CB_post_float(cam_angleRotationDeg);
		CB_post_float(cam_angleRotationRad);

		/******************** Post-conditions execution *********************/

		/*no Post-conditions*/
	}

	/*************************** self update ****************************/

	self.Bool += 3;
	self.Float += 5;

	return 0;
}

