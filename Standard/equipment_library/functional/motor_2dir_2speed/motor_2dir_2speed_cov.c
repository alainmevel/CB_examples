/*2023-10-03T11:13:09-01:00*/

/********************************************************************
 * motor_2dir_2speed_cov.c
 * 
 * generated by: plcgen 3.1.391
 ********************************************************************/

#include "cb_comp.h"
#include "cb_covs.h"
#include "iec_1131.h"

#include "motor_2dir_2speed.h"



/**************************** Variables *****************************/

CB_Index motor_2dir_2speed__num = 0;
CB_Mem_Bool *motor_2dir_2speed_voltage380;
CB_Mem_Bool *motor_2dir_2speed_cmdSupply;
CB_Mem_Bool *motor_2dir_2speed_sensorSupply;
CB_Mem_Bool *motor_2dir_2speed_forward;
CB_Mem_Bool *motor_2dir_2speed_backward;
CB_Mem_Bool *motor_2dir_2speed_highSpeed;
CB_Mem_Bool *motor_2dir_2speed_lowSpeed;
CB_Mem_Bool *motor_2dir_2speed_forwardFB;
CB_Mem_Bool *motor_2dir_2speed_backwardFB;
CB_Mem_Bool *motor_2dir_2speed_highSpeedFB;
CB_Mem_Bool *motor_2dir_2speed_lowSpeedFB;
CB_Mem_Bool *motor_2dir_2speed_thermal;
CB_Mem_Float *motor_2dir_2speed_speedVal;
CB_Mem_Float *motor_2dir_2speed_speedPercent;
CB_Mem_Float *motor_2dir_2speed_increment;
CB_Mem_Bool *motor_2dir_2speed_memoFwd;
CB_Mem_Bool *motor_2dir_2speed_memoBwd;
CB_Mem_Bool *motor_2dir_2speed_memoHighSpeed;
CB_Mem_Bool *motor_2dir_2speed_memoLowSpeed;
CB_Mem_Bool *motor_2dir_2speed_FwdHsState;
CB_Mem_Bool *motor_2dir_2speed_FwdLsState;
CB_Mem_Bool *motor_2dir_2speed_BwdHsState;
CB_Mem_Bool *motor_2dir_2speed_BwdLsState;
CB_Mem_Float *motor_2dir_2speed_wantedSpeed;
CB_Mem_Float *motor_2dir_2speed_nominalTime;
CB_Mem_Bool *motor_2dir_2speed_thermalLogic;
CB_Mem_Bool *motor_2dir_2speed_fwdFbLogic;
CB_Mem_Bool *motor_2dir_2speed_bwdFbLogic;
CB_Mem_Bool *motor_2dir_2speed_highSpeedFbLogic;
CB_Mem_Bool *motor_2dir_2speed_lowSpeedFbLogic;
CB_Mem_Float *motor_2dir_2speed_nominalLowSpeed;
CB_Mem_Float *motor_2dir_2speed_nominalHighSpeed;
CB_Mem_Bool *motor_2dir_2speed_d_locking;
CB_Mem_Float *motor_2dir_2speed_v_d_locking;
CB_Mem_Bool *motor_2dir_2speed_d_electrical;
CB_Mem_Bool *motor_2dir_2speed_v_d_electrical;
CB_Mem_Bool *motor_2dir_2speed_d_forwardFB;
CB_Mem_Bool *motor_2dir_2speed_v_d_forwardFB;
CB_Mem_Bool *motor_2dir_2speed_d_highSpeedFB;
CB_Mem_Bool *motor_2dir_2speed_v_d_highSpeedFB;
CB_Mem_Bool *motor_2dir_2speed_d_lowSpeedFB;
CB_Mem_Bool *motor_2dir_2speed_v_d_lowSpeedFB;
CB_Mem_Bool *motor_2dir_2speed_d_backwardFB;
CB_Mem_Bool *motor_2dir_2speed_v_d_backwardFB;

/**************************** Variables *****************************/

#define voltage380 (motor_2dir_2speed_voltage380->CB_current_value)
#define cmdSupply (motor_2dir_2speed_cmdSupply->CB_current_value)
#define sensorSupply (motor_2dir_2speed_sensorSupply->CB_current_value)
#define forward (motor_2dir_2speed_forward->CB_current_value)
#define backward (motor_2dir_2speed_backward->CB_current_value)
#define highSpeed (motor_2dir_2speed_highSpeed->CB_current_value)
#define lowSpeed (motor_2dir_2speed_lowSpeed->CB_current_value)
#define forwardFB (motor_2dir_2speed_forwardFB->CB_current_value)
#define backwardFB (motor_2dir_2speed_backwardFB->CB_current_value)
#define highSpeedFB (motor_2dir_2speed_highSpeedFB->CB_current_value)
#define lowSpeedFB (motor_2dir_2speed_lowSpeedFB->CB_current_value)
#define thermal (motor_2dir_2speed_thermal->CB_current_value)
#define speedVal (motor_2dir_2speed_speedVal->CB_current_value)
#define speedPercent (motor_2dir_2speed_speedPercent->CB_current_value)
#define increment (motor_2dir_2speed_increment->CB_current_value)
#define memoFwd (motor_2dir_2speed_memoFwd->CB_current_value)
#define memoBwd (motor_2dir_2speed_memoBwd->CB_current_value)
#define memoHighSpeed (motor_2dir_2speed_memoHighSpeed->CB_current_value)
#define memoLowSpeed (motor_2dir_2speed_memoLowSpeed->CB_current_value)
#define FwdHsState (motor_2dir_2speed_FwdHsState->CB_current_value)
#define FwdLsState (motor_2dir_2speed_FwdLsState->CB_current_value)
#define BwdHsState (motor_2dir_2speed_BwdHsState->CB_current_value)
#define BwdLsState (motor_2dir_2speed_BwdLsState->CB_current_value)
#define wantedSpeed (motor_2dir_2speed_wantedSpeed->CB_current_value)
#define nominalTime (motor_2dir_2speed_nominalTime->CB_current_value)
#define thermalLogic (motor_2dir_2speed_thermalLogic->CB_current_value)
#define fwdFbLogic (motor_2dir_2speed_fwdFbLogic->CB_current_value)
#define bwdFbLogic (motor_2dir_2speed_bwdFbLogic->CB_current_value)
#define highSpeedFbLogic (motor_2dir_2speed_highSpeedFbLogic->CB_current_value)
#define lowSpeedFbLogic (motor_2dir_2speed_lowSpeedFbLogic->CB_current_value)
#define nominalLowSpeed (motor_2dir_2speed_nominalLowSpeed->CB_current_value)
#define nominalHighSpeed (motor_2dir_2speed_nominalHighSpeed->CB_current_value)
#define d_locking (motor_2dir_2speed_d_locking->CB_current_value)
#define v_d_locking (motor_2dir_2speed_v_d_locking->CB_current_value)
#define d_electrical (motor_2dir_2speed_d_electrical->CB_current_value)
#define v_d_electrical (motor_2dir_2speed_v_d_electrical->CB_current_value)
#define d_forwardFB (motor_2dir_2speed_d_forwardFB->CB_current_value)
#define v_d_forwardFB (motor_2dir_2speed_v_d_forwardFB->CB_current_value)
#define d_highSpeedFB (motor_2dir_2speed_d_highSpeedFB->CB_current_value)
#define v_d_highSpeedFB (motor_2dir_2speed_v_d_highSpeedFB->CB_current_value)
#define d_lowSpeedFB (motor_2dir_2speed_d_lowSpeedFB->CB_current_value)
#define v_d_lowSpeedFB (motor_2dir_2speed_v_d_lowSpeedFB->CB_current_value)
#define d_backwardFB (motor_2dir_2speed_d_backwardFB->CB_current_value)
#define v_d_backwardFB (motor_2dir_2speed_v_d_backwardFB->CB_current_value)


/************************ Components offsets ************************/


/********************* Initialization function **********************/

int _equipment_library__motor_2dir_2speed_init(void)
{
	(motor_2dir_2speed_voltage380)->CB_current_value = 1; /*voltage380*/
	(motor_2dir_2speed_cmdSupply)->CB_current_value = 1; /*cmdSupply*/
	(motor_2dir_2speed_sensorSupply)->CB_current_value = 1; /*sensorSupply*/
	(self.Float+2)->CB_current_value = 0.5; /*nominalTime*/
	(self.Bool+9)->CB_current_value = 1; /*fwdFbLogic*/
	(self.Bool+10)->CB_current_value = 1; /*bwdFbLogic*/
	(self.Bool+11)->CB_current_value = 1; /*highSpeedFbLogic*/
	(self.Bool+12)->CB_current_value = 1; /*lowSpeedFbLogic*/
	(self.Float+3)->CB_current_value = 2500.0; /*nominalLowSpeed*/
	(self.Float+4)->CB_current_value = 5000.0; /*nominalHighSpeed*/
	(self.Float+5)->CB_current_value = 0.5; /*v_d_locking*/
	self.Bool+=24;
	self.Float+=6;


	return 0;
}


/************************ Behavior function *************************/

int equipment_library__motor_2dir_2speed(void)
{
	static char *__comp_name = "equipment_library.motor_2dir_2speed";
	if (exec_term_node(self_num)) {

		/*********************** Internals variables ************************/

		motor_2dir_2speed_increment = self.Float+0;
		motor_2dir_2speed_memoFwd = self.Bool+0;
		motor_2dir_2speed_memoBwd = self.Bool+1;
		motor_2dir_2speed_memoHighSpeed = self.Bool+2;
		motor_2dir_2speed_memoLowSpeed = self.Bool+3;
		motor_2dir_2speed_FwdHsState = self.Bool+4;
		motor_2dir_2speed_FwdLsState = self.Bool+5;
		motor_2dir_2speed_BwdHsState = self.Bool+6;
		motor_2dir_2speed_BwdLsState = self.Bool+7;
		motor_2dir_2speed_wantedSpeed = self.Float+1;
		motor_2dir_2speed_nominalTime = self.Float+2;
		motor_2dir_2speed_thermalLogic = self.Bool+8;
		motor_2dir_2speed_fwdFbLogic = self.Bool+9;
		motor_2dir_2speed_bwdFbLogic = self.Bool+10;
		motor_2dir_2speed_highSpeedFbLogic = self.Bool+11;
		motor_2dir_2speed_lowSpeedFbLogic = self.Bool+12;
		motor_2dir_2speed_nominalLowSpeed = self.Float+3;
		motor_2dir_2speed_nominalHighSpeed = self.Float+4;
		motor_2dir_2speed_d_locking = self.Bool+13;
		motor_2dir_2speed_v_d_locking = self.Float+5;
		motor_2dir_2speed_d_electrical = self.Bool+14;
		motor_2dir_2speed_v_d_electrical = self.Bool+15;
		motor_2dir_2speed_d_forwardFB = self.Bool+16;
		motor_2dir_2speed_v_d_forwardFB = self.Bool+17;
		motor_2dir_2speed_d_highSpeedFB = self.Bool+18;
		motor_2dir_2speed_v_d_highSpeedFB = self.Bool+19;
		motor_2dir_2speed_d_lowSpeedFB = self.Bool+20;
		motor_2dir_2speed_v_d_lowSpeedFB = self.Bool+21;
		motor_2dir_2speed_d_backwardFB = self.Bool+22;
		motor_2dir_2speed_v_d_backwardFB = self.Bool+23;

		/********************* Pre-conditions execution *********************/

		/*no Pre-conditions*/

		/************************ Behavior execution ************************/

		{
			/* ----------------------------------------------------------------	*/
			/* Type : Model of Operative Behaviour					*/
			/* Category :  Associations - motors					*/
			/* Author : Dassault Systemes						*/
			/* Update date : June 2010							*/
			/* ----------------------------------------------------------------	*/
			/* This module simulates a motor with 2 directions and 2 speeds	*/
			/* and its electrical control logic.					*/
			/* ----------------------------------------------------------------	*/


			/* ----------------------------------------------------------------	*/
			/* Management of orders from Control Part					*/
			/*	if there is no power supply for command 				*/
			/*     	the contactors don't understand the control order	*/
			/*	The contactors cannot be active in the same time		*/
			/*	 	(mechanical security).					*/
			/* ----------------------------------------------------------------	*/
			if (forward && !memoBwd && cmdSupply) memoFwd = 1;
			if (!forward || !cmdSupply || d_electrical) memoFwd = 0;
			if (!memoFwd && backward && cmdSupply) memoBwd = 1;
			if (!backward || !cmdSupply || d_electrical) memoBwd = 0;

			if (!memoHighSpeed && lowSpeed && cmdSupply) memoLowSpeed = 1;
			if (!lowSpeed || !cmdSupply || d_electrical) memoLowSpeed = 0;
			if (highSpeed && !memoLowSpeed && cmdSupply) memoHighSpeed = 1;
			if (!highSpeed || !cmdSupply || d_electrical) memoHighSpeed = 0;

			/* ----------------------------------------------------------------	*/
			/* Calculation of the on-state of contactor				*/
			/* ----------------------------------------------------------------	*/
			FwdHsState = memoFwd & memoHighSpeed & voltage380;
			FwdLsState = memoFwd & memoLowSpeed & voltage380;
			BwdHsState = memoBwd & memoHighSpeed & voltage380;
			BwdLsState = memoBwd & memoLowSpeed & voltage380;


			/* ----------------------------------------------------------------	*/
			/* Management of the speed ramp						*/
			/* ----------------------------------------------------------------	*/
			if (d_locking)  speedVal = v_d_locking;
			else {
				/* compute the wanted speed	*/
				if (FwdHsState) {
					wantedSpeed = nominalHighSpeed;
					if (nominalTime > 0.0)
						increment=(nominalHighSpeed/nominalTime)*(CLOCK_PERIOD/1000000.0);
				}
				else if (FwdLsState) {
					wantedSpeed = nominalLowSpeed;
					if (nominalTime > 0.0)
						increment=(nominalLowSpeed/nominalTime)*(CLOCK_PERIOD/1000000.0);
				}
				if (BwdHsState) {
					wantedSpeed = nominalHighSpeed * -1.0;
					increment=(nominalHighSpeed/nominalTime)*(CLOCK_PERIOD/1000000.0);
				}
				else if (BwdLsState) {
					wantedSpeed = nominalLowSpeed * -1.0;
					increment=(nominalLowSpeed/nominalTime)*(CLOCK_PERIOD/1000000.0);
				}
				 if (! FwdHsState && ! FwdLsState && ! BwdHsState && ! BwdLsState) wantedSpeed = 0.0;


				/* Compute the speed ramp	*/
				if ( speedVal < wantedSpeed) {
					speedVal += increment;
					if ( speedVal > wantedSpeed) speedVal = wantedSpeed;
				}
				if ( speedVal > wantedSpeed) {
					speedVal -= increment;
					if (speedVal < wantedSpeed) speedVal = wantedSpeed;
				}
			}

			/* ----------------------------------------------------------------	*/
			/* Compute the percentage between the current and nominal speed	*/
			/* ----------------------------------------------------------------	*/
			if (nominalHighSpeed != 0.0)
				speedPercent = ((speedVal/nominalHighSpeed)*100);

			/* ----------------------------------------------------------------	*/
			/* Management of the thermal feedback					*/
			/* ----------------------------------------------------------------	*/
			if (d_electrical) thermal=v_d_electrical;
			else
				thermal= ! thermalLogic && sensorSupply;

			/* ----------------------------------------------------------------	*/
			/* Management of feedback to Control Part					*/
			/*     if a fault is required, the contactor feed-back 		*/
			/*		 takes a preset state.					*/
			/*	if there is no power supply for sensors 				*/
			/*         contactor feed-back returns nothing				*/
			/*     else contactor feed-back returns the contactor state combined	*/
			/*	    with wiring logic.						*/
			/* ----------------------------------------------------------------	*/
			if (d_forwardFB) forwardFB = v_d_forwardFB;
			else
				forwardFB=(memoFwd ^ ! fwdFbLogic) && sensorSupply;

			if (d_backwardFB) backwardFB = v_d_backwardFB;
			else
				backwardFB = (memoBwd ^ ! bwdFbLogic) && sensorSupply;

			if (d_highSpeedFB) highSpeedFB = v_d_highSpeedFB;
			else
				highSpeedFB = (memoHighSpeed ^ ! highSpeedFbLogic) && sensorSupply;

			if (d_lowSpeedFB) lowSpeedFB = v_d_lowSpeedFB;
			else
				lowSpeedFB = (memoLowSpeed ^ ! lowSpeedFbLogic) && sensorSupply;



		}

		CB_post_bool(motor_2dir_2speed_forwardFB);
		CB_post_bool(motor_2dir_2speed_backwardFB);
		CB_post_bool(motor_2dir_2speed_highSpeedFB);
		CB_post_bool(motor_2dir_2speed_lowSpeedFB);
		CB_post_bool(motor_2dir_2speed_thermal);
		CB_post_float(motor_2dir_2speed_speedVal);
		CB_post_float(motor_2dir_2speed_speedPercent);

		/******************** Post-conditions execution *********************/

		/*no Post-conditions*/
	}

	/*************************** self update ****************************/

	self.Bool += 24;
	self.Float += 6;

	return 0;
}

